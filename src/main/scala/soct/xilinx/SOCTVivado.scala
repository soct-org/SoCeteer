package soct.xilinx


import chisel3.experimental.OpaqueType
import chisel3.reflect.DataMirror
import chisel3.util.DecoupledIO
import chisel3.{ActualDirection, Aggregate, Bundle, Data, Element, Vec}
import freechips.rocketchip.amba.axi4._
import freechips.rocketchip.devices.debug.{JTAG, SystemJTAGIO}
import freechips.rocketchip.util.BundleMap
import org.chipsalliance.cde.config.Parameters
import org.chipsalliance.diplomacy.nodes.HeterogeneousBag
import soct.SOCTLauncher.SOCTConfig
import soct.xilinx.components._
import soct.{BoardSOCTPaths, ChiselCompat, ChiselTop, HasBdBuilder, HasDDR4ExtMem, HasSDCardPMOD, HasSOCTConfig, HasSOCTPaths, HasXilinxFPGA, LastRocketSystem, SOCTUtils, log}
import soct.xilinx.fpga.{FPGA, ZCU104}

import java.nio.file.{Files, Path}
import scala.collection.immutable.{AbstractSeq, LinearSeq}
import scala.collection.mutable
import scala.util.matching.Regex
import scala.xml.NodeSeq


/**
 * Exception thrown during evaluation of a Xilinx design
 */
case class XilinxDesignException(private val message: String = "",
                                 private val cause: Throwable = None.orNull)
  extends Exception(message, cause)


/**
 * Registry for known FPGA boards.
 */
object FPGARegistry {

  /**
   * Resolve a board by name
   *
   * @param name Name of the board
   * @return Some(FPGA) if found, None otherwise
   */
  def resolve(name: String): Option[FPGA] = {
    val comp = name.toLowerCase

    if (comp == ZCU104.friendlyName.toLowerCase) {
      Some(ZCU104)
    } else {
      None
    }
  }

  /**
   * List of available boards
   */
  def availableBoards: Seq[String] = {
    Seq(
      ZCU104.friendlyName
    )
  }
}

class BDBuilder() {
  private var p: Option[Parameters] = None

  private val components = mutable.Set.empty[BdComp]

  private val instantiateCommands: mutable.ListBuffer[String] = mutable.ListBuffer.empty

  private val portCommands: mutable.ListBuffer[String] = mutable.ListBuffer.empty


  /**
   * Initialize the BDBuilder with parameters
   *
   * @param p Parameters
   */
  def init(p: Parameters): Unit = {
    this.p = Some(p)
  }

  private def checkInit(): Unit = {
    if (p.isEmpty) {
      throw XilinxDesignException("BDBuilder not initialized with parameters")
    }
  }

  def add[T <: BdComp](c: T): Unit = {
    if (!components.contains(c)) {
      c.checkAvailable()
      components += c
    }
  }

  def portModifications(): Map[String, Seq[String]] = {
    val allPortMods = mutable.Map.empty[String, Seq[String]]
    components.foreach {
      case xIntf: BdXInterface =>
        val portMods = xIntf.portMapping
        portMods.foreach { case (portName, annotations) =>
          // Append to existing annotations if present
          val existing = allPortMods.getOrElse(portName, Seq.empty)
          allPortMods(portName) = existing ++ annotations
        }
      case _ =>
    }
    allPortMods.toMap
  }

  def generateTcl(): String = {
    components.foreach {
      case inst: InstantiableBdComp =>
        instantiateCommands ++= inst.tclCommands
      case port: BdPort =>
        portCommands ++= port.tclCommands
      case xport: XilinxBdIntfPort =>
        portCommands ++= xport.tclCommands
      case c =>
        log.warn(s"Unknown type: ${c.friendlyName}")
    }

    // First declare all ports
    val portsTcl = portCommands.mkString("\n")
    // Then instantiate all components
    val instTcl = instantiateCommands.mkString("\n")
    // Combine both (very simple for now)
    s"""# Auto-generated Vivado TCL script
       |# Generated by SOCT
       |
       |# Declare ports
       |${portsTcl}
       |
       |
       |# Instantiate components
       |${instTcl}
       |""".stripMargin
  }


  /**
   * Generate Vivado init script
   * @param aggressive Whether to generate which acts aggressively, e.g., overwriting existing projects/sources etc.
   * @return TCl script as string
   */
  def generateInitScript(aggressive: Boolean): String = {
    checkInit()
    final case class TclVar(description: String, default: String)

    object k {
      final val aggressive = "$aggressive"
      final val sources = "$sources"
      final val projectName = "$project_name"
      final val xilinxPart = "$xilinx_part"
      final val partName = "$part_name"
      final val sourcesDir = "$sources_dir"
      final val vivadoProjectDir = "$vivado_project_dir"
    }

    // Map of variable names to their descriptions and default values
    val m: Map[String, TclVar] = {
      // Use new scope to prevent using any project dependencies without defining a variable
      val p: Parameters = this.p.get
      val paths = p(HasSOCTPaths).asInstanceOf[BoardSOCTPaths]
      val config = p(HasSOCTConfig)
      val fpga = p(HasXilinxFPGA).get
      Map(
        k.aggressive -> TclVar("Whether to aggressively overwrite existing Vivado projects and sources", if (aggressive) "1" else "0"),
        k.sources -> TclVar("The name of the fileset containing the design sources", "sources_1"),
        k.projectName -> TclVar("The name of the Vivado project to create or open", s"soct-${config.configName}-${fpga.friendlyName.replaceAll("-", "_")}"),
        k.xilinxPart -> TclVar("The Xilinx part number of the target FPGA", fpga.xilinxPart),
        k.partName -> TclVar("The Xilinx part name of the target FPGA", fpga.partName),
        k.sourcesDir -> TclVar("The directory containing the design sources", paths.systemDir.toString),
        k.vivadoProjectDir -> TclVar("The directory to use for the Vivado project", paths.vivadoProjectDir.toString),
      )
    }

    // generate header with variable descriptions, using all vals in object v
    val header = m.map { case (v, TclVar(description, default)) =>
      // Strip the leading $ from the variable name
      val varName = v.stripPrefix("$")
      s"""
         |# $varName: $description
         |if {[info exists $varName] == 0} {set $varName "$default"}""".stripMargin
    }.mkString("\n") + "\n"


    s"""# Auto-generated Vivado TCL script
       |# Generated by SOCT
       |
       |# Header with variable descriptions
       |$header
       |
       |# If there is no project opened, create a project for the design
       |if {[llength [get_projects -quiet]] == 0} {
       |  # https://docs.amd.com/r/en-US/ug835-vivado-tcl-commands/create_project
       |  if {${k.aggressive} == 1} {
       |    create_project -force -part ${k.xilinxPart} ${k.projectName} ${k.vivadoProjectDir}
       |  } else {
       |    create_project -part ${k.xilinxPart} ${k.projectName} ${k.vivadoProjectDir}
       |  }
       |  set_property board_part ${k.partName} [current_project]
       |}
       |
       |# Create "${k.sources}" fileset (if not found)
       |if {[llength [get_filesets -quiet ${k.sources}]] == 0} {
       |  create_fileset -srcset ${k.sources}
       |}
       |
       |set source_fileset [get_filesets ${k.sources}]
       |# https://docs.amd.com/r/en-US/ug835-vivado-tcl-commands/add_files
       |add_files -fileset $$source_fileset ${k.sourcesDir}
       |
       |""".stripMargin
  }
}

object SOCTVivado {


  val DEFAULT_MEMORY_ADDR_64: BigInt = BigInt("80000000", 16)

  val DEFAULT_MEMORY_ADDR_32: BigInt = BigInt("40000000", 16)

  val DEFAULT_MMIO_ADDR = "0x60000000"

  val TAB_SIZE = 2

  /** Convert a name to snake_case */
  def snake(name: String): String = {
    name.toLowerCase.replace(".", "_")
  }

  /**
   * Add Vivado port mappings to the given lines
   *
   * @param portLines    Lines of the Verilog file containing the port declarations
   * @param portMappings Map of port names to Vivado attribute strings
   * @return Modified lines with Vivado annotations added
   */
  private def addPortMappings(
                               portLines: Seq[String],
                               portMappings: Map[String, Seq[String]],
                             ): Seq[String] = {
    val lines = mutable.Buffer.from(portLines)
    portMappings.foreach { case (portName, attrStrings) =>
      val lineIdxOpt = lines.zipWithIndex.find { case (line, _) =>
        line.contains(s"$portName")
      }.map { case (_, idx) => idx }
      if (lineIdxOpt.isEmpty) {
        soct.log.warn(s"Could not find port line for port $portName to add Vivado annotation")
      } else {
        val lineIdx = lineIdxOpt.get
        val ws = " " * TAB_SIZE
        // Insert the annotations before the line - see https://docs.amd.com/r/en-US/ug994-vivado-ip-subsystems/General-Usage
        attrStrings.reverse.foreach { attrString =>
          lines.insert(lineIdx, ws + attrString)
        }
      }
    }
    lines.toSeq
  }

  /**
   * Vivado does not allow a SystemVerilog top-level.
   * We do a highly illegal trick here by just renaming the file extension,
   * hoping that Chisel did not include any SystemVerilog-specific constructs in the top-level module.
   * Note that this is not guaranteed to work and may break in future Chisel versions.
   *
   * @param boardPaths Paths to the board
   * @param config     SOCT configuration
   * @return Path to the (new) top-level Verilog file
   */
  private def convertTopModuleFile(boardPaths: BoardSOCTPaths, config: SOCTConfig): Path = {
    val file = boardPaths.verilogSystem.toFile
    if (file.isFile) {
      return boardPaths.verilogSystem
    }

    if (!file.isDirectory) {
      throw XilinxDesignException(s"Verilog system path ${boardPaths.verilogSystem} is neither a file nor a directory")
    }

    // Get all files in the directory recursively
    val svFiles = Files.walk(boardPaths.verilogSystem)
      .filter(p => p.toString.endsWith(".sv"))
      .toArray
      .map(_.asInstanceOf[Path])

    val topModuleName = config.topModule.fold(_.getSimpleName, _.getSimpleName)

    // We now check if the name of the top module matches any of the files
    val topModuleFileOpt = svFiles.find { p =>
      p.getFileName.toString.equals(s"$topModuleName.sv")
    }

    if (topModuleFileOpt.isEmpty) {
      throw XilinxDesignException(s"Could not find SystemVerilog file for top module $topModuleName in directory ${boardPaths.verilogSystem}")
    } else {
      val topModuleFile = topModuleFileOpt.get
      val newTopModuleFile = topModuleFile.resolveSibling(topModuleFile.getFileName.toString.replace(".sv", ".v"))
      Files.move(topModuleFile, newTopModuleFile)
      soct.log.info(s"Renamed top module file ${topModuleFile.getFileName} to ${newTopModuleFile.getFileName} for Vivado compatibility")
      newTopModuleFile
    }
  }

  /**
   * Regex to match a Verilog module declaration. Has three capture groups:
   * 1: module moduleName (
   * 2: port declarations
   * 3: );
   *
   * @param moduleName Name of the module
   * @return Regex to match the module declaration
   */
  private def verilogModuleRegex(moduleName: String): Regex =
    s"""(?s)(module\\s+$moduleName\\s*\\()(.*?)(\\)\\s*;)""".r


  private def extractPortLines(topVerilog: String, topModuleName: String): Seq[String] = {
    val m = verilogModuleRegex(topModuleName).findFirstMatchIn(topVerilog).getOrElse {
      throw XilinxDesignException(
        s"Could not find module declaration for top module $topModuleName"
      )
    }
    m.group(2).linesIterator.toSeq
  }


  private def patchPortLines(topVerilog: String, topModuleName: String, newPortLines: Seq[String]): String = {
    val regex = verilogModuleRegex(topModuleName)

    val m = regex.findFirstMatchIn(topVerilog).getOrElse {
      throw XilinxDesignException(
        s"Could not find module declaration for top module $topModuleName"
      )
    }
    val moduleStart = m.group(1)
    val moduleEnd = m.group(3)
    val ports = newPortLines.mkString("\n") + "\n"
    val replacement = s"$moduleStart$ports$moduleEnd"
    regex.replaceFirstIn(topVerilog, replacement)
  }


  def prepareForVivado(boardPaths: BoardSOCTPaths, config: SOCTConfig): Unit = {
    val rs = LastRocketSystem.instance.getOrElse {
      throw XilinxDesignException("No RocketSystem instance found for Vivado generation - did you elaborate the design?")
    }
    implicit val p: Parameters = rs.p
    implicit val bd: BDBuilder = p(HasBdBuilder).getOrElse(
      throw XilinxDesignException("No BDBuilder found in parameters for SOCTVivadoTop")
    )


    val topModuleFile: Path = convertTopModuleFile(boardPaths, config)
    val topVerilog = Files.readString(topModuleFile)
    val topModuleName = config.topModule.fold(_.getSimpleName, _.getSimpleName)

    val portLines = extractPortLines(topVerilog, topModuleName)
    val portMappings = bd.portModifications()
    val transformed = patchPortLines(topVerilog, topModuleName, addPortMappings(portLines, portMappings))
    Files.writeString(topModuleFile, transformed)

    val initTCL = bd.generateInitScript(aggressive = config.args.overrideVivadoProject)
    Files.writeString(boardPaths.tclInitFile, initTCL)
  }

  def generateProject(tclFile: Path, vivado: Path): Unit = {
    val workDir = tclFile.getParent
    val file = tclFile.toAbsolutePath.toString
    var cmd = Seq(vivado.toAbsolutePath.toString, "-mode", "batch", "-source")
    cmd :+= file
    val process = new ProcessBuilder(cmd: _*)
      .directory(workDir.toFile)
      .inheritIO()
      .start()
    val exitCode = process.waitFor()
    if (exitCode != 0) {
      throw new RuntimeException(s"Vivado failed with exit code $exitCode")
    }
  }
}
