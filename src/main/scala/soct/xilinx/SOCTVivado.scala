package soct.xilinx


import org.chipsalliance.cde.config.Parameters
import soct.{HasBdBuilder, HasSOCTConfig, HasSOCTPaths, HasXilinxFPGA, LastRocketSystem, VivadoSOCTPaths}
import soct.SOCTLauncher.SOCTConfig
import soct.xilinx.components._
import soct.xilinx.fpga.{FPGA, ZCU104}

import java.nio.file.{Files, Path}
import scala.collection.mutable
import scala.reflect.io.Path.jfile2path
import scala.util.matching.Regex


/**
 * Exception thrown during evaluation of a Xilinx design
 */
case class XilinxDesignException(private val message: String = "",
                                 private val cause: Throwable = None.orNull)
  extends Exception(message, cause)


/**
 * Registry for known FPGA boards.
 */
object FPGARegistry {

  /**
   * Resolve a board by name
   *
   * @param name Name of the board
   * @return Some(FPGA) if found, None otherwise
   */
  def resolve(name: String): Option[FPGA] = {
    val comp = name.toLowerCase

    if (comp == ZCU104.friendlyName.toLowerCase) {
      Some(ZCU104)
    } else {
      None
    }
  }

  /**
   * List of available boards
   */
  def availableBoards: Seq[String] = {
    Seq(
      ZCU104.friendlyName
    )
  }
}

class BDBuilder() {
  private val components = mutable.Set.empty[BdComp]

  private val instantiateCommands: mutable.ListBuffer[String] = mutable.ListBuffer.empty

  private val portCommands: mutable.ListBuffer[String] = mutable.ListBuffer.empty

  final case class TclVar(description: String, default: String)

  private def genTCLHeader(vars: Map[String, TclVar]): String = {
    val varDecls = vars.map { case (v, TclVar(description, default)) =>
      // Strip the leading $ from the variable name
      val varName = v.stripPrefix("$")
      s"""
         |# $varName: $description
         |if {[info exists $varName] == 0} {set $varName "$default"}""".stripMargin
    }.mkString("\n") + "\n"

    s"""# Auto-generated Vivado TCL script
       |# Generated by SOCT
       |
       |# Header with variable descriptions - modify as needed
       |$varDecls""".stripMargin
  }

  // Map of variable names to their descriptions and default values
  private var vars: Map[String, TclVar] = Map.empty

  // Keys for TCL variables
  object k {
    final val aggressive = "$aggressive"
    final val sources = "$sources"
    final val projectName = "$project_name"
    final val bdName = "$bd_name"
    final val xilinxPart = "$xilinx_part"
    final val partName = "$part_name"
    final val sourcesDir = "$sources_dir"
    final val vivadoProjectDir = "$vivado_project_dir"
    final val bdLoadFile = "$bd_load_file"
  }

  /**
   * Initialize the BDBuilder with parameters
   *
   * @param p Parameters
   */
  def init(p: Parameters): Unit = {
    val paths = p(HasSOCTPaths).asInstanceOf[VivadoSOCTPaths]
    val config = p(HasSOCTConfig)
    val fpga = p(HasXilinxFPGA).get
    val aggressive = config.args.overrideVivadoProject

    vars = Map(
      k.aggressive -> TclVar("Whether to aggressively overwrite existing Vivado projects and sources", if (aggressive) "1" else "0"),
      k.sources -> TclVar("The name of the fileset containing the design sources", "sources_1"),
      k.projectName -> TclVar("The name of the Vivado project to create or open", s"${config.topModuleName}"),
      k.bdName -> TclVar("The name of the block design to create", s"${config.topModuleName}_bd"),
      k.xilinxPart -> TclVar("The Xilinx part number of the target FPGA", fpga.xilinxPart),
      k.partName -> TclVar("The Xilinx part name of the target FPGA", fpga.partName),
      k.sourcesDir -> TclVar("The directory containing the design sources", paths.systemDir.toString),
      k.vivadoProjectDir -> TclVar("The directory to use for the Vivado project", paths.vivadoProjectDir.toString),
      k.bdLoadFile -> TclVar("The TCL file to load the block design", paths.bdLoadFile.toString)
    )
  }

  private def checkInit(): Unit = {
    // check if vars is initialized
    if (vars.isEmpty) {
      throw XilinxDesignException("BDBuilder not initialized - call init(p: Parameters) before generating scripts")
    }
  }

  def add[T <: BdComp](c: T): Unit = {
    if (!components.contains(c)) {
      c.checkAvailable()
      components += c
    }
  }

  def portModifications(): Map[String, Seq[String]] = {
    val allPortMods = mutable.Map.empty[String, Seq[String]]
    components.foreach {
      case xIntf: BdXInterface =>
        val portMods = xIntf.portMapping
        portMods.foreach { case (portName, annotations) =>
          // Append to existing annotations if present
          val existing = allPortMods.getOrElse(portName, Seq.empty)
          allPortMods(portName) = existing ++ annotations
        }
      case _ =>
    }
    allPortMods.toMap
  }

  def emitCollaterals(outDir: Path): Unit = {
    components.foreach { c =>
      c.dumpCollaterals(outDir)
    }
  }

  def generateBoardTcl(): String = {
    components.foreach {
      case inst: InstantiableBdComp =>
        instantiateCommands ++= inst.tclCommands
      case port: BdPort =>
        portCommands ++= port.tclCommands
      case xport: XilinxBdIntfPort =>
        portCommands ++= xport.tclCommands
      case c =>
        soct.log.warn(s"Unknown type: ${c.friendlyName}")
    }

    // First declare all ports
    val portsTcl = portCommands.mkString("\n")
    // Then instantiate all components
    val instTcl = instantiateCommands.mkString("\n")

    // Keys for TCL variables used in the script
    val bdKeys = Seq(k.bdName, k.projectName)

    // generate header with variable descriptions, using a subset of vals in vars
    val bdVars: Map[String, TclVar] = vars.filter { case (v, _) => bdKeys.contains(v) }


    s"""${genTCLHeader(bdVars)}
       |
       |# Helper procedures
       |proc error_exit {id msg} {
       |  common::send_gid_msg -ssname BD::TCL -id $$id -severity "ERROR" $$msg
       |  error $$msg
       |}
       |
       |proc warn_msg {id msg} {
       |  common::send_gid_msg -ssname BD::TCL -id $$id -severity "WARNING" $$msg
       |}
       |
       |proc info_msg {id msg} {
       |  common::send_gid_msg -ssname BD::TCL -id $$id -severity "INFO" $$msg
       |}
       |
       |# Check if the current project matches the expected project name
       |if {[llength [get_projects -quiet]] == 0} {
       |  error_exit 2000 "No Vivado project is opened. Please open a project before sourcing this script."
       |} else {
       |  set current_proj [get_property NAME [current_project]]
       |  if {$$current_proj ne ${k.projectName}} {
       |    warn_msg 2001 "This script is intended for project ${k.projectName}, but current project is $$current_proj. If you don't know what you are doing, please create a new project with https://github.com/soct-org/SoCeteer. Continuing may lead to unexpected results."
       |  }
       |}
       |
       |# Capture current context (design + instance scope)
       |set cur_design [current_bd_design -quiet]
       |set cur_inst [current_bd_instance -quiet]
       |
       |set bd_exists [llength [get_bd_designs -quiet ${k.bdName}]]
       |
       |
       |if {$$bd_exists == 0} {
       |  # If there is an existing block design opened, close it
       |  if {[llength $$cur_design] != 0} {
       |    warn_msg 2002 "Other block designs is currently opened. Closing it to continue."
       |    save_bd_design $$cur_design
       |    close_bd_design $$cur_design
       |  }
       |  create_bd_design ${k.bdName}
       |} else {
       |  # Ensure requested BD is the current BD for the emptiness check
       |  if {[llength $$cur_design] == 0} {
       |    open_bd_design ${k.bdName}
       |  } elseif {$$cur_design ne ${k.bdName}} {
       |    warn_msg 2003 "Other block design is currently opened. Closing it to validate / open the requested block design."
       |    save_bd_design $$cur_design
       |    close_bd_design $$cur_design
       |    open_bd_design ${k.bdName}
       |  } else {
       |    # Same BD already current; no-op
       |  }
       |
       |  set n_cells [llength [get_bd_cells -quiet *]]
       |  set n_ports [llength [get_bd_ports -quiet *]]
       |  set n_iports [llength [get_bd_intf_ports -quiet *]]
       |  set n_nets [llength [get_bd_nets -quiet *]]
       |
       |  if {($$n_cells + $$n_ports + $$n_iports + $$n_nets) != 0} {
       |    # Restore previous context (best effort)
       |    if {[llength $$cur_design] != 0 && $$cur_design ne ${k.bdName}} {
       |      open_bd_design $$cur_design
       |      if {[llength $$cur_inst] != 0} {
       |        catch { current_bd_instance $$cur_inst }
       |      }
       |    }
       |    error_exit 2004 "Block design ${k.bdName} already exists and is not empty. Aborting to avoid overwriting existing design."
       |  }
       |}
       |
       |info_msg 2005 "Created / opened block design ${k.bdName} successfully."
       |
       |# Declare ports
       |${portsTcl}
       |
       |
       |# Instantiate components
       |${instTcl}
       |""".stripMargin
  }


  /**
   * Generate Vivado init script
   *
   * @return TCl script as string
   */
  def generateInitScript(): String = {
    checkInit()

    s"""${genTCLHeader(vars)}
       |
       |# If there is no project opened, create a project for the design
       |if {[llength [get_projects -quiet]] == 0} {
       |  # https://docs.amd.com/r/en-US/ug835-vivado-tcl-commands/create_project
       |  if {${k.aggressive} == 1} {
       |    create_project -force -part ${k.xilinxPart} ${k.projectName} ${k.vivadoProjectDir}
       |  } else {
       |    create_project -part ${k.xilinxPart} ${k.projectName} ${k.vivadoProjectDir}
       |  }
       |  set_property board_part ${k.partName} [current_project]
       |}
       |
       |# Create fileset if not found.
       |if {[llength [get_filesets -quiet ${k.sources}]] == 0} {
       |  create_fileset -srcset ${k.sources}
       |}
       |
       |set source_fileset [get_filesets ${k.sources}]
       |# https://docs.amd.com/r/en-US/ug835-vivado-tcl-commands/add_files
       |add_files -fileset $$source_fileset ${k.sourcesDir}
       |
       |# TODO add other filesets (constraints, etc.)
       |
       |source ${k.bdLoadFile}
       |
       |""".stripMargin
  }
}


object SOCTVivado {


  val DEFAULT_MEMORY_ADDR_64: BigInt = BigInt("80000000", 16)

  val DEFAULT_MEMORY_ADDR_32: BigInt = BigInt("40000000", 16)

  val DEFAULT_MMIO_ADDR = "0x60000000"

  val TAB_SIZE = 2

  /** Convert a name to snake_case */
  def snake(name: String): String = {
    name.toLowerCase.replace(".", "_")
  }

  /**
   * Add Vivado port mappings to the given lines
   *
   * @param portLines    Lines of the Verilog file containing the port declarations
   * @param portMappings Map of port names to Vivado attribute strings
   * @return Modified lines with Vivado annotations added
   */
  private def addPortMappings(
                               portLines: Seq[String],
                               portMappings: Map[String, Seq[String]],
                             ): Seq[String] = {
    val lines = mutable.Buffer.from(portLines)
    portMappings.foreach { case (portName, attrStrings) =>
      val lineIdxOpt = lines.zipWithIndex.find { case (line, _) =>
        line.contains(s"$portName")
      }.map { case (_, idx) => idx }
      if (lineIdxOpt.isEmpty) {
        soct.log.warn(s"Could not find port line for port $portName to add Vivado annotation")
      } else {
        val lineIdx = lineIdxOpt.get
        val ws = "\t" * TAB_SIZE
        // Insert the annotations before the line - see https://docs.amd.com/r/en-US/ug994-vivado-ip-subsystems/General-Usage
        attrStrings.reverse.foreach { attrString =>
          lines.insert(lineIdx, ws + attrString)
        }
      }
    }
    lines.toSeq
  }

  /**
   * Vivado does not allow a SystemVerilog top-level.
   * We do a highly illegal trick here by just renaming the file extension,
   * hoping that Chisel did not include any SystemVerilog-specific constructs in the top-level module.
   * Note that this is not guaranteed to work and may break in future Chisel versions.
   *
   * @param boardPaths Paths to the board
   * @param config     SOCT configuration
   * @param convert    Whether to perform the conversion (renaming). If false, just returns the path.
   * @return Path to the (new) top-level Verilog file
   */
  private def getTopModuleFile(boardPaths: VivadoSOCTPaths, config: SOCTConfig, convert: Boolean = true): Path = {
    val endings = Seq(".v", ".sv")

    // Get all files in the directory recursively
    val vFiles = Files.walk(boardPaths.verilogSrc)
      .filter(p => Files.isRegularFile(p) && endings.exists(e => p.getFileName.toString.endsWith(e)))
      .toArray
      .map(_.asInstanceOf[Path])

    // We now check if the name of the top module matches any of the files
    val topModuleFileOpt = vFiles.find { p =>
      val fileName = p.getFileName.toString
      val baseName = fileName.substring(0, fileName.indexOf('.')) // strip all extensions
      baseName == config.topModuleName
    }

    if (topModuleFileOpt.isEmpty) {
      throw XilinxDesignException(s"Could not find top module file for module ${config.topModuleName} in ${boardPaths.verilogSrc}")
    }

    val topModuleFile = topModuleFileOpt.get
    val fileName = topModuleFile.getFileName.toString

    // If no conversion is needed or is verilog already, return as is
    if (!convert || fileName.endsWith(".v"))
      return topModuleFileOpt.get

    val newTopModuleFile = topModuleFile.resolveSibling(fileName.replace(".sv", ".v"))
    Files.move(topModuleFile, newTopModuleFile)
    soct.log.info(s"Renamed top module file ${topModuleFile.getFileName} to ${newTopModuleFile.getFileName} for Vivado compatibility")
    newTopModuleFile
  }

  /**
   * Regex to match a Verilog module declaration. Has three capture groups:
   * 1: module moduleName (
   * 2: port declarations
   * 3: );
   *
   * @param moduleName Name of the module
   * @return Regex to match the module declaration
   */
  private def verilogModuleRegex(moduleName: String): Regex =
    s"""(?s)(module\\s+$moduleName\\s*\\()(.*?)(\\)\\s*;)""".r


  private def extractPortLines(topVerilog: String, topModuleName: String): Seq[String] = {
    val m = verilogModuleRegex(topModuleName).findFirstMatchIn(topVerilog).getOrElse {
      throw XilinxDesignException(
        s"Could not find module declaration for top module $topModuleName"
      )
    }
    m.group(2).linesIterator.toSeq
  }


  private def patchPortLines(topVerilog: String, topModuleName: String, newPortLines: Seq[String]): String = {
    val regex = verilogModuleRegex(topModuleName)

    val m = regex.findFirstMatchIn(topVerilog).getOrElse {
      throw XilinxDesignException(
        s"Could not find module declaration for top module $topModuleName"
      )
    }
    val moduleStart = m.group(1)
    val moduleEnd = m.group(3)
    val ports = newPortLines.mkString("\n") + "\n"
    val replacement = s"$moduleStart$ports$moduleEnd"
    regex.replaceFirstIn(topVerilog, replacement)
  }


  def prepareForVivado(boardPaths: VivadoSOCTPaths, config: SOCTConfig, removeVerification: Boolean = true): Unit = {
    val rs = LastRocketSystem.instance.getOrElse {
      throw XilinxDesignException("No RocketSystem instance found for Vivado generation - did you elaborate the design?")
    }
    implicit val p: Parameters = rs.p
    implicit val bd: BDBuilder = p(HasBdBuilder).getOrElse(
      throw XilinxDesignException("No BDBuilder found in parameters for SOCTVivadoTop")
    )


    val topModuleFile: Path = getTopModuleFile(boardPaths, config)
    val topVerilog = Files.readString(topModuleFile)

    val portLines = extractPortLines(topVerilog, config.topModuleName)
    val portMappings = bd.portModifications()
    val transformed = patchPortLines(topVerilog, config.topModuleName, addPortMappings(portLines, portMappings))
    Files.writeString(topModuleFile, transformed)

    val initTCL = bd.generateInitScript()
    Files.writeString(boardPaths.tclInitFile, initTCL)

    val bdTCL = bd.generateBoardTcl()
    Files.writeString(boardPaths.bdLoadFile, bdTCL)

    // dump collaterals for all components
    bd.emitCollaterals(boardPaths.verilogSrc)

    if (removeVerification) {
      val verificationDir = boardPaths.verilogSrc.resolve("verification")
      if (verificationDir.toFile.exists()) {
        soct.log.info(s"Removing verification directory at $verificationDir for Vivado synthesis")
        verificationDir.toFile.deleteRecursively()
      }
    }
  }

  def generateProject(tclFile: Path, vivado: Path, workdir: Path): Unit = {
    val file = tclFile.toAbsolutePath.toString
    var cmd = Seq(vivado.toAbsolutePath.toString, "-mode", "batch", "-source")
    cmd :+= file
    val process = new ProcessBuilder(cmd: _*)
      .directory(workdir.toFile)
      .inheritIO()
      .start()
    val exitCode = process.waitFor()
    if (exitCode != 0) {
      throw new RuntimeException(s"Vivado failed with exit code $exitCode")
    }
  }
}
