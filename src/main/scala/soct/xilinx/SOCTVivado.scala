package soct.xilinx


import chisel3.reflect.DataMirror
import chisel3.util.DecoupledIO
import chisel3.{ActualDirection, Bundle, Data}
import freechips.rocketchip.amba.axi4._
import freechips.rocketchip.util.BundleMap
import org.chipsalliance.cde.config.Parameters
import org.chipsalliance.diplomacy.nodes.HeterogeneousBag
import soct.SOCTLauncher.SOCTConfig
import soct.xilinx.components._
import soct.{BoardSOCTPaths, ChiselTop, HasDDR4ExtMem, HasSDCardPMOD, HasSOCTConfig, HasSOCTPaths, LastRocketSystem, SOCTUtils, log}
import soct.xilinx.fpga.{FPGA, ZCU104}

import java.nio.file.{Files, Path}
import scala.collection.mutable
import scala.util.matching.Regex


/**
 * Exception thrown during evaluation of a Xilinx design
 */
case class XilinxDesignException(private val message: String = "",
                                 private val cause: Throwable = None.orNull)
  extends Exception(message, cause)


/**
 * Registry for known FPGA boards.
 */
object FPGARegistry {

  /**
   * Resolve a board by name
   *
   * @param name Name of the board
   * @return Some(FPGA) if found, None otherwise
   */
  def resolve(name: String): Option[FPGA] = {
    val comp = name.toLowerCase

    if (comp == ZCU104.friendlyName.toLowerCase) {
      Some(ZCU104)
    } else {
      None
    }
  }

  /**
   * List of available boards
   */
  def availableBoards: Seq[String] = {
    Seq(
      ZCU104.friendlyName
    )
  }
}

class BDBuilder(implicit p: Parameters, top: ChiselTop) {
  private val paths = p(HasSOCTPaths)
  private val config = p(HasSOCTConfig)

  private val components = mutable.Set.empty[BdComp]

  // TCL commands:
  private val instantiateCommands: mutable.ListBuffer[String] = mutable.ListBuffer.empty

  private val portCommands: mutable.ListBuffer[String] = mutable.ListBuffer.empty

  def add[T <: BdComp](c: T): Unit = {
    if (!components.contains(c)) {
      c.checkAvailable()
      components += c
    }
  }

  def generateTcl(): String = {
    components.foreach {
      case inst: InstantiableBdComp =>
        instantiateCommands ++= inst.tclCommands
      case port: BdPort =>
        portCommands ++= port.tclCommands
      case xport: XilinxBdIntfPort =>
        portCommands ++= xport.tclCommands
      case c =>
        log.warn(s"Unknown type: ${c.friendlyName}")
    }

    // First declare all ports
    val portsTcl = portCommands.mkString("\n")
    // Then instantiate all components
    val instTcl = instantiateCommands.mkString("\n")
    // Combine both (very simple for now)
    s"""# Auto-generated Vivado TCL script
       |# Generated by SOCT
       |
       |# Declare ports
       |${portsTcl}
       |
       |
       |# Instantiate components
       |${instTcl}
       |""".stripMargin
  }
}

object SOCTVivado {


  val DEFAULT_MEMORY_ADDR_64: BigInt = BigInt("80000000", 16)

  val DEFAULT_MEMORY_ADDR_32: BigInt = BigInt("40000000", 16)

  val DEFAULT_MMIO_ADDR = "0x60000000"

  val TAB_SIZE = 2

  val PERIPHERY_CLOCK_FREQ_HZ: Long = 100_000_000

  /** Convert a name to snake_case */
  def snake(name: String): String = {
    name.toLowerCase.replace(".", "_")
  }


  private case class InterfaceInfo(partName: String, ignoredPorts: Set[String], freqHz: Long)

  /**
   * Add Vivado port mappings to the given lines
   *
   * @param lines        Lines of the Verilog file containing the port declarations
   * @param portMappings Map of port names to Vivado attribute strings
   */
  private def addPortMappings(
                               lines: mutable.Buffer[String],
                               portMappings: Map[String, Seq[String]],
                             ): Unit = {
    portMappings.foreach { case (portName, attrStrings) =>
      val lineIdxOpt = lines.zipWithIndex.find { case (line, _) =>
        line.contains(s"$portName")
      }.map { case (_, idx) => idx }
      if (lineIdxOpt.isEmpty) {
        soct.log.warn(s"Could not find port line for port $portName to add Vivado annotation")
      } else {
        val lineIdx = lineIdxOpt.get
        val ws = " " * TAB_SIZE
        // Insert the annotations before the line - see https://docs.amd.com/r/en-US/ug994-vivado-ip-subsystems/General-Usage
        attrStrings.reverse.foreach { attrString =>
          lines.insert(lineIdx, ws + attrString)
        }
      }
    }
  }


  /**
   * Annotate the given Verilog port lines with Vivado X_INTERFACE_INFO attributes for the given AXI4 interface
   *
   * @param ifName  Name of the interface
   * @param axiPort AXI4Bundle to annotate
   * @param lines   Lines of the Verilog file containing the port declarations
   * @param intf    InterfaceInfo containing details about the interface
   * @return New lines with X_INTERFACE_INFO lines added
   */
  private def annotateAsAXI(
                             ifName: String,
                             axiPort: AXI4Bundle,
                             lines: Seq[String],
                             intf: InterfaceInfo = InterfaceInfo(
                               partName = "xilinx.com:interface:aximm:1.0",
                               ignoredPorts = Set("bits", "user", "echo"),
                               freqHz = PERIPHERY_CLOCK_FREQ_HZ
                             )
                           ): Seq[String] = {
    val portMappings = mutable.Map.empty[String, Seq[String]]

    axiPort.elements.foreach { case (channelName, channel) =>
      DataMirror.collectMembers(channel) {
          case data: Bundle => data.elements
        }
        .foldLeft(Map.empty[String, Data])(_ ++ _)
        .filterNot { case (fieldName, _) => intf.ignoredPorts.contains(fieldName) }
        .foreach { case (fieldName, port) =>
          val portName = snake(port.instanceName)
          val xilinxName = s"${channelName.toUpperCase}${fieldName.toUpperCase()}"
          val intfString = s"(* X_INTERFACE_INFO = \"${intf.partName} $ifName $xilinxName\" *)"
          val paramString = if (channel == axiPort.aw && port == axiPort.aw.bits.addr) {
            Some(s"(* X_INTERFACE_PARAMETER = \"XIL_INTERFACENAME $ifName, PROTOCOL AXI4, DATA_WIDTH ${axiPort.params.dataBits}, ADDR_WIDTH ${axiPort.params.addrBits}, FREQ_HZ ${intf.freqHz}\" *)")
          } else {
            None
          }
          val annotations = paramString match {
            case Some(param) => Seq(param, intfString)
            case None => Seq(intfString)
          }
          if (portMappings.contains(portName)) {
            soct.log.warn(s"Port $portName already has Vivado annotations, overwriting")
          }
          portMappings(portName) = annotations
        }
    }


    val newLines = lines.to(mutable.Buffer)
    addPortMappings(newLines, portMappings.toMap)
    newLines.toSeq
  }

  /**
   * Vivado does not allow a SystemVerilog top-level.
   * We do a highly illegal trick here by just renaming the file extension,
   * hoping that Chisel did not include any SystemVerilog-specific constructs in the top-level module.
   * Note that this is not guaranteed to work and may break in future Chisel versions.
   *
   * @param boardPaths Paths to the board
   * @param config     SOCT configuration
   * @return Path to the (new) top-level Verilog file
   */
  private def convertTopModuleFile(boardPaths: BoardSOCTPaths, config: SOCTConfig): Path = {
    val file = boardPaths.verilogSystem.toFile
    if (file.isFile) {
      return boardPaths.verilogSystem
    }

    if (!file.isDirectory) {
      throw XilinxDesignException(s"Verilog system path ${boardPaths.verilogSystem} is neither a file nor a directory")
    }

    // Get all files in the directory recursively
    val svFiles = Files.walk(boardPaths.verilogSystem)
      .filter(p => p.toString.endsWith(".sv"))
      .toArray
      .map(_.asInstanceOf[Path])

    val topModuleName = config.topModule.fold(_.getSimpleName, _.getSimpleName)

    // We now check if the name of the top module matches any of the files
    val topModuleFileOpt = svFiles.find { p =>
      p.getFileName.toString.equals(s"$topModuleName.sv")
    }

    if (topModuleFileOpt.isEmpty) {
      throw XilinxDesignException(s"Could not find SystemVerilog file for top module $topModuleName in directory ${boardPaths.verilogSystem}")
    } else {
      val topModuleFile = topModuleFileOpt.get
      val newTopModuleFile = topModuleFile.resolveSibling(topModuleFile.getFileName.toString.replace(".sv", ".v"))
      Files.move(topModuleFile, newTopModuleFile)
      soct.log.info(s"Renamed top module file ${topModuleFile.getFileName} to ${newTopModuleFile.getFileName} for Vivado compatibility")
      newTopModuleFile
    }
  }

  /**
   * Regex to match a Verilog module declaration. Has three capture groups:
   * 1: module moduleName (
   * 2: port declarations
   * 3: );
   *
   * @param moduleName Name of the module
   * @return Regex to match the module declaration
   */
  private def verilogModuleRegex(moduleName: String): Regex =
    s"""(?s)(module\\s+$moduleName\\s*\\()(.*?)(\\)\\s*;)""".r


  private def extractPortLines(topVerilog: String, topModuleName: String): Seq[String] = {
    val m = verilogModuleRegex(topModuleName).findFirstMatchIn(topVerilog).getOrElse {
      throw XilinxDesignException(
        s"Could not find module declaration for top module $topModuleName"
      )
    }
    m.group(2).linesIterator.toSeq
  }


  private def patchPortLines(topVerilog: String, topModuleName: String, newPortLines: Seq[String]): String = {
    val regex = verilogModuleRegex(topModuleName)

    val m = regex.findFirstMatchIn(topVerilog).getOrElse {
      throw XilinxDesignException(
        s"Could not find module declaration for top module $topModuleName"
      )
    }
    val moduleStart = m.group(1)
    val moduleEnd = m.group(3)
    val ports = newPortLines.mkString("\n") + "\n"
    val replacement = s"$moduleStart$ports$moduleEnd"
    regex.replaceFirstIn(topVerilog, replacement)
  }


  def generate(boardPaths: BoardSOCTPaths, config: SOCTConfig): Unit = {
    val rs = LastRocketSystem.instance.getOrElse {
      throw XilinxDesignException("No RocketSystem instance found for Vivado generation - did you elaborate the design?")
    }
    implicit val top: ChiselTop = Right(rs.getClass)
    implicit val p: Parameters = rs.p
    implicit val bd: BDBuilder = new BDBuilder

    if (p(HasDDR4ExtMem).isDefined) {
      DDR4(
        ddr4Idx = p(HasDDR4ExtMem).get,
        intf = DDR4BdIntfPort()
      )
    }

    if (p(HasSDCardPMOD).isDefined) {
      SDCardPMOD(
        pmodIdx = p(HasSDCardPMOD).get,
        cdPort = SDIOCDPort(),
        clkPort = SDIOClkPort(),
        cmdPort = SDIOCmdPort(),
        dataPort = SDIODataPort()
      )
    }

    val topModuleFile: Path = convertTopModuleFile(boardPaths, config)
    val topVerilog = Files.readString(topModuleFile)
    val topModuleName = config.topModule.fold(_.getSimpleName, _.getSimpleName)

    var portLines = extractPortLines(topVerilog, topModuleName)

    // Annotate AXI4 interfaces - Every RocketSystem has these
    val axiInfts = Seq(rs.mem_axi4, rs.mmio_axi4, rs.l2_frontend_bus_axi4).flatten
    axiInfts.foreach { axiBundle =>
      // How to address the interface
      val ifName = snake(axiBundle.instanceName)
      portLines = annotateAsAXI(ifName, axiBundle, portLines)
    }

    val tcl = bd.generateTcl()

    println(tcl)

    val newTopVerilog = patchPortLines(topVerilog, topModuleName, portLines)
    Files.writeString(topModuleFile, newTopVerilog)
  }

  def generateProject(tclFile: Path, vivado: Path, vivadoSettings: Option[Path]): Unit = {
    // On windows, it should be a .bat file
    if (SOCTUtils.isWindows) {
      println("Not implemented yet")
    } else if (SOCTUtils.isUnix) {
      var cmd = s"${vivado.toAbsolutePath} -mode batch -source ${tclFile.toAbsolutePath}"
      if (vivadoSettings.isDefined) {
        cmd = s"source ${vivadoSettings.get} && $cmd"
      }
      val args = Seq("bash", "-c", cmd)
      println("Running Vivado with command: " + args.mkString(" "))
      val process = new ProcessBuilder(args: _*).directory(tclFile.getParent.toFile).inheritIO().start()
      val exitCode = process.waitFor()
      if (exitCode != 0) {
        throw new RuntimeException(s"Vivado failed with exit code $exitCode")
      }
    }
  }
}
