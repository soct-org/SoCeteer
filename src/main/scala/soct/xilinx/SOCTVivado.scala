package soct.xilinx


import chisel3.reflect.DataMirror
import chisel3.Data
import freechips.rocketchip.amba.axi4._
import org.chipsalliance.cde.config.Parameters
import org.chipsalliance.diplomacy.nodes.HeterogeneousBag
import soct.SOCTLauncher.SOCTConfig
import soct.xilinx.components._
import soct.{BoardSOCTPaths, ChiselTop, HasSOCTConfig, HasSOCTPaths, SOCTUtils, log}
import soct.xilinx.fpga.{FPGA, ZCU104}

import java.nio.file.{Files, Path}
import scala.collection.mutable


/**
 * Exception thrown during evaluation of a Xilinx design
 */
case class XilinxDesignException(private val message: String = "",
                                 private val cause: Throwable = None.orNull)
  extends Exception(message, cause)


/**
 * Registry for known FPGA boards.
 */
object FPGARegistry {

  /**
   * Resolve a board by name
   *
   * @param name Name of the board
   * @return Some(FPGA) if found, None otherwise
   */
  def resolve(name: String): Option[FPGA] = {
    val comp = name.toLowerCase

    if (comp == ZCU104.friendlyName.toLowerCase) {
      Some(ZCU104)
    } else {
      None
    }
  }

  /**
   * List of available boards
   */
  def availableBoards: Seq[String] = {
    Seq(
      ZCU104.friendlyName
    )
  }
}

class BDBuilder(implicit p: Parameters, top: ChiselTop) {
  private val paths = p(HasSOCTPaths)
  private val config = p(HasSOCTConfig)

  private val components = mutable.Set.empty[BdComp]

  // TCL commands:
  private val instantiateCommands: mutable.ListBuffer[String] = mutable.ListBuffer.empty

  private val portCommands: mutable.ListBuffer[String] = mutable.ListBuffer.empty

  def add[T <: BdComp](c: T): Unit = {
    if (!components.contains(c)) {
      c.checkAvailable()
      components += c
    }
  }

  def generateTcl(): String = {
    components.foreach {
      case inst: InstantiableBdComp =>
        instantiateCommands ++= inst.tclCommands
      case port: BdPort =>
        portCommands ++= port.tclCommands
      case xport: XilinxBdIntfPort =>
        portCommands ++= xport.tclCommands
      case c =>
        log.warn(s"Unknown type: ${c.friendlyName}")
    }

    // First declare all ports
    val portsTcl = portCommands.mkString("\n")
    // Then instantiate all components
    val instTcl = instantiateCommands.mkString("\n")
    // Combine both (very simple for now)
    s"""# Auto-generated Vivado TCL script
       |# Generated by SOCT
       |
       |# Declare ports
       |${portsTcl}
       |
       |
       |# Instantiate components
       |${instTcl}
       |""".stripMargin
  }
}

object SOCTVivado {


  val DEFAULT_MEMORY_ADDR_64: BigInt = BigInt("80000000", 16)

  val DEFAULT_MEMORY_ADDR_32: BigInt = BigInt("40000000", 16)

  val DEFAULT_MMIO_ADDR = "0x60000000"

  def annotateAsAXI(
                   ifName: String,
                   axiPorts: HeterogeneousBag[AXI4Bundle],
                   partName: String = "xilinx.com:interface:aximm:1.0"
                   ): Unit = {


    axiPorts.elements.foreach {case (name, bundle) =>
      bundle.elements.foreach { case (channelName, channel) =>
        // Use the DataMirror to map the chisel names to known interface names
        // AXI4BundleR/AW etc are always the data part, all other fields have standard names
        DataMirror.collectMembers(channel) {
          case data: AXI4BundleAW => println(s"Found AW channel")
          case data: AXI4BundleW => println(s"Found W channel")
          case data: AXI4BundleB => println(s"Found B channel")
          case data: AXI4BundleAR => println(s"Found AR channel")
          case data: AXI4BundleR => println(s"Found R channel")
          case data: Data =>


        }
      }
    }
  }



  def generate(boardPaths: BoardSOCTPaths, config: SOCTConfig): Unit = {
    // Vivado does not allow a SystemVerilog top-level.
    // We do a highly illegal trick here by just renaming the file extension,
    // hoping that Chisel did not include any SystemVerilog-specific constructs in the top-level module.
    // Note that this is not guaranteed to work and may break in future Chisel versions.
    if (boardPaths.verilogSystem.toFile.isDirectory) {
      // Get all files in the directory recursively
      val svFiles = Files.walk(boardPaths.verilogSystem)
        .filter(p => p.toString.endsWith(".sv"))
        .toArray
        .map(_.asInstanceOf[Path])

      val topModuleName = config.topModule.fold(_.getSimpleName, _.getSimpleName)
      // We now check if the name of the top module matches any of the files
      val topModuleFileOpt = svFiles.find { p =>
        p.getFileName.toString.equals(s"$topModuleName.sv")
      }
      if (topModuleFileOpt.isEmpty) {
        throw XilinxDesignException(s"Could not find SystemVerilog file for top module $topModuleName in directory ${boardPaths.verilogSystem}")
      } else {
        val topModuleFile = topModuleFileOpt.get
        val newTopModuleFile = topModuleFile.resolveSibling(topModuleFile.getFileName.toString.replace(".sv", ".v"))
        Files.move(topModuleFile, newTopModuleFile)
        soct.log.info(s"Renamed top module file ${topModuleFile.getFileName} to ${newTopModuleFile.getFileName} for Vivado compatibility")
      }
    }
  }

  def generateProject(tclFile: Path, vivado: Path, vivadoSettings: Option[Path]): Unit = {
    // On windows, it should be a .bat file
    if (SOCTUtils.isWindows) {
      println("Not implemented yet")
    } else if (SOCTUtils.isUnix) {
      var cmd = s"${vivado.toAbsolutePath} -mode batch -source ${tclFile.toAbsolutePath}"
      if (vivadoSettings.isDefined) {
        cmd = s"source ${vivadoSettings.get} && $cmd"
      }
      val args = Seq("bash", "-c", cmd)
      println("Running Vivado with command: " + args.mkString(" "))
      val process = new ProcessBuilder(args: _*).directory(tclFile.getParent.toFile).inheritIO().start()
      val exitCode = process.waitFor()
      if (exitCode != 0) {
        throw new RuntimeException(s"Vivado failed with exit code $exitCode")
      }
    }
  }
}
