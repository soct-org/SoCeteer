package soct.system.vivado

import org.chipsalliance.cde.config.Parameters
import soct.{HasSOCTConfig, HasSOCTPaths, HasXilinxFPGA, VivadoSOCTPaths}
import soct.system.vivado.components.{BdComp, BdPort, BdXInterface, InstantiableBdComp, IsModule, IsXilinxIP, XilinxBdIntfPort}

import java.nio.file.Path
import scala.collection.mutable

class SOCTBdBuilder {
  private val components = mutable.Set.empty[BdComp]

  private final case class TclVar(description: String, default: String)

  private def genTCLHeader(vars: Map[String, TclVar]): String = {
    val varDecls = vars.map { case (v, TclVar(description, default)) =>
      // Strip the leading $ from the variable name
      val varName = v.stripPrefix("$")
      s"""
         |# $varName: $description
         |if {[info exists $varName] == 0} {set $varName "$default"}""".stripMargin
    }.mkString("\n") + "\n"

    s"""# Auto-generated Vivado TCL script
       |# Generated by SOCT
       |
       |# Header with variable descriptions - modify as needed
       |$varDecls""".stripMargin
  }

  // Map of variable names to their descriptions and default values
  private var vars: Map[String, TclVar] = Map.empty

  // Keys for TCL variables
  object k {
    final val aggressive = "$aggressive"
    final val sources = "$sources"
    final val projectName = "$project_name"
    final val bdName = "$bd_name"
    final val xilinxPart = "$xilinx_part"
    final val partName = "$part_name"
    final val sourcesDir = "$sources_dir"
    final val vivadoProjectDir = "$vivado_project_dir"
    final val bdLoadFile = "$bd_load_file"
  }

  /**
   * Get the top-level instance representing the design in the block design
   */
  var topInstance: () => InstantiableBdComp with IsModule = () => {
    throw XilinxDesignException("Please call init before accessing topInstance")
  }


  /**
   * Initialize the BDBuilder with parameters and top-level instance. MUST be called before generating scripts or adding components.
   *
   * @param p       Parameters
   * @param topInst Top-level instantiable block design component
   */
  def init(p: Parameters, topInst: InstantiableBdComp with IsModule): Unit = {
    val paths = p(HasSOCTPaths).asInstanceOf[VivadoSOCTPaths]
    val config = p(HasSOCTConfig)
    val fpga = p(HasXilinxFPGA).get
    val aggressive = config.args.overrideVivadoProject
    topInstance = () => topInst

    vars = Map(
      k.aggressive -> TclVar("Whether to aggressively overwrite existing Vivado projects and sources", if (aggressive) "1" else "0"),
      k.sources -> TclVar("The name of the fileset containing the design sources", "sources_1"),
      k.projectName -> TclVar("The name of the Vivado project to create or open", s"${config.topModuleName}"),
      k.bdName -> TclVar("The name of the block design to create", s"${config.topModuleName}_bd"),
      k.xilinxPart -> TclVar("The Xilinx part number of the target FPGA", fpga.xilinxPart),
      k.partName -> TclVar("The Xilinx part name of the target FPGA", fpga.partName),
      k.sourcesDir -> TclVar("The directory containing the design sources", paths.systemDir.toString),
      k.vivadoProjectDir -> TclVar("The directory to use for the Vivado project", paths.vivadoProjectDir.toString),
      k.bdLoadFile -> TclVar("The TCL file to load the block design", paths.bdLoadFile.toString)
    )
  }

  private def checkInit(): Unit = {
    // check if vars is initialized
    if (vars.isEmpty) {
      throw XilinxDesignException("BDBuilder not initialized - call init(p: Parameters) before generating scripts")
    }
  }

  def add[T <: BdComp](c: T): Unit = {
    if (!components.contains(c)) {
      c.checkAvailable()
      components += c
    }
  }

  def portModifications(): Map[String, Seq[String]] = {
    val allPortMods = mutable.Map.empty[String, Seq[String]]
    components.foreach {
      case xIntf: BdXInterface =>
        val portMods = xIntf.portMapping
        portMods.foreach { case (portName, annotations) =>
          // Append to existing annotations if present
          val existing = allPortMods.getOrElse(portName, Seq.empty)
          allPortMods(portName) = existing ++ annotations
        }
      case _ =>
    }
    allPortMods.toMap
  }

  def emitCollaterals(outDir: Path): Unit = {
    components.foreach { c =>
      c.dumpCollaterals(outDir)
    }
  }

  def generateBoardTcl(): String = {
    val instantiateCommands, connectCommands, portCommands: mutable.ListBuffer[String] = mutable.ListBuffer.empty[String]

    components.foreach {
      case inst: InstantiableBdComp =>
        instantiateCommands ++= inst.instTclCommands
        connectCommands ++= inst.connectTclCommands
      case port: BdPort =>
        portCommands ++= port.tclCommands
      case xport: XilinxBdIntfPort =>
        portCommands ++= xport.tclCommands
      case c =>
        soct.log.warn(s"Unknown type: ${c.friendlyName}")
    }

    // Get all components that have default properties that are not an empty map
    val componentsWithProperties = components.collect {
      case c: InstantiableBdComp if c.defaultProperties.nonEmpty => c
    }

    // Generate a set_property command for each component with default properties
    val propertyCommands = componentsWithProperties.map { c =>
      s"""
         |# Set default properties for component ${c.friendlyName}
         |set_property -dict [list \\
         |${c.defaultProperties.map { case (k, v) => s"  $k {$v}" }.mkString(" \\\n") + " \\"}
         |] $$${c.instanceName}
         |""".stripMargin
    }

    // Keys for TCL variables used in the script
    val bdKeys = Seq(k.bdName, k.projectName, k.sources)

    // generate header with variable descriptions, using a subset of vals in vars
    val bdVars: Map[String, TclVar] = vars.filter { case (v, _) => bdKeys.contains(v) }

    // Collect all Xilinx IP components which are instantiable
    val xilinxIps = components.collect {
      case ip: InstantiableBdComp if ip.isInstanceOf[IsXilinxIP] => ip.asInstanceOf[IsXilinxIP]
    }

    val modules = components.collect {
      case m: InstantiableBdComp if m.isInstanceOf[IsModule] => m.asInstanceOf[IsModule]
    }

    s"""${genTCLHeader(bdVars)}
       |
       |######## Helper procedures ########
       |proc error_exit {id msg} {
       |  common::send_gid_msg -ssname BD::TCL -id $$id -severity "ERROR" $$msg
       |  error $$msg
       |}
       |
       |proc warn_msg {id msg} {
       |  common::send_gid_msg -ssname BD::TCL -id $$id -severity "WARNING" $$msg
       |}
       |
       |proc info_msg {id msg} {
       |  common::send_gid_msg -ssname BD::TCL -id $$id -severity "INFO" $$msg
       |}
       |
       |
       |######## Project & Board design (bd) validation ########
       |
       |# Check if the current project matches the expected project name
       |if {[llength [get_projects -quiet]] == 0} {
       |  error_exit 2000 "No Vivado project is opened. Please open a project before sourcing this script."
       |} else {
       |  set current_proj [get_property NAME [current_project]]
       |  if {$$current_proj ne ${k.projectName}} {
       |    warn_msg 2001 "This script is intended for project ${k.projectName}, but current project is $$current_proj. If you don't know what you are doing, please create a new project with https://github.com/soct-org/SoCeteer. Continuing may lead to unexpected results."
       |  }
       |}
       |
       |# Save current BD context (best effort)
       |set cur_design [current_bd_design -quiet]
       |set cur_inst   [current_bd_instance -quiet]
       |
       |# Construct BD file path (Vivado-standard layout)
       |set bd_file [file join \\
       |  [get_property DIRECTORY [current_project]] \\
       |  ${k.projectName}.srcs \\
       |  ${k.sources} \\
       |  bd \\
       |  ${k.bdName} \\
       |  ${k.bdName}.bd]
       |
       |# Open existing BD or create a new one
       |if {[file exists $$bd_file]} {
       |  # Ensure the BD is part of the current project before opening
       |  if {[llength [get_files -quiet $$bd_file]] == 0} {
       |    add_files -norecurse $$bd_file
       |  }
       |  open_bd_design $$bd_file
       |} else {
       |  create_bd_design ${k.bdName}
       |}
       |
       |current_bd_design ${k.bdName}
       |
       |# Check whether the BD is empty
       |set n_cells  [llength [get_bd_cells -quiet *]]
       |set n_ports  [llength [get_bd_ports -quiet *]]
       |set n_iports [llength [get_bd_intf_ports -quiet *]]
       |set n_nets   [llength [get_bd_nets -quiet *]]
       |
       |if {($$n_cells + $$n_ports + $$n_iports + $$n_nets) != 0} {
       |  # Restore previous context (best effort)
       |  if {[llength $$cur_design] != 0 && $$cur_design ne ${k.bdName}} {
       |    open_bd_design $$cur_design
       |    if {[llength $$cur_inst] != 0} {
       |      catch { current_bd_instance $$cur_inst }
       |    }
       |  }
       |  error_exit 2004 "Block design ${k.bdName} already exists and is not empty. Aborting to avoid overwriting existing design."
       |}
       |
       |info_msg 2005 "Created / opened block design ${k.bdName} successfully."
       |
       |
       |######## Check for required Xilinx IPs ########
       |
       |set list_ips_missing {}
       |set list_check_ips [list \\
       |${xilinxIps.map(_.partName).map(ip => s"  \"$ip\"").mkString(" \\\n")}
       |]
       |foreach ip_name $$list_check_ips {
       |  if {[llength [get_ipdefs -all $$ip_name]] == 0} {
       |    lappend list_ips_missing $$ip_name
       |  }
       |}
       |if {[llength $$list_ips_missing] != 0} {
       |  error_exit 2006 "The following required Xilinx IPs are missing: \\n  [join $$list_ips_missing "\\n  "]\\nPlease install them via the Vivado IP Catalog before sourcing this script."
       |}
       |
       |info_msg 2007 "All required Xilinx IPs are available."
       |
       |
       |######## Check for required Modules ########
       |
       |set list_modules_missing {}
       |set list_check_modules [list \\
       |${modules.map(_.reference).map(m => s"  \"$m\"").mkString(" \\\n")}
       |]
       |foreach mod_name $$list_check_modules {
       |  if {[llength [can_resolve_reference $$mod_name]] == 0} {
       |    lappend list_modules_missing $$mod_name
       |  }
       |}
       |if {[llength $$list_modules_missing] != 0} {
       |  error_exit 2008 "The following required Modules are missing: \\n  [join $$list_modules_missing "\\n  "]\\nPlease ensure their collateral files are available in the sources directory before sourcing this script."
       |}
       |
       |info_msg 2009 "All required Modules are available."
       |
       |# Declare ports
       |${portCommands.mkString("\n")}
       |
       |# Instantiate components
       |${instantiateCommands.mkString("\n")}
       |
       |# Set default properties
       |${propertyCommands.mkString("\n")}
       |
       |# Connect components
       |${connectCommands.mkString("\n")}
       |
       |""".stripMargin
  }


  /**
   * Generate Vivado init script
   *
   * @return TCl script as string
   */
  def generateInitScript(): String = {
    checkInit()

    s"""${genTCLHeader(vars)}
       |
       |# If there is no project opened, create a project for the design
       |if {[llength [get_projects -quiet]] == 0} {
       |  # https://docs.amd.com/r/en-US/ug835-vivado-tcl-commands/create_project
       |  if {${k.aggressive} == 1} {
       |    create_project -force -part ${k.xilinxPart} ${k.projectName} ${k.vivadoProjectDir}
       |  } else {
       |    create_project -part ${k.xilinxPart} ${k.projectName} ${k.vivadoProjectDir}
       |  }
       |  set_property board_part ${k.partName} [current_project]
       |}
       |
       |# Create fileset if not found.
       |if {[llength [get_filesets -quiet ${k.sources}]] == 0} {
       |  create_fileset -srcset ${k.sources}
       |}
       |
       |set source_fileset [get_filesets ${k.sources}]
       |# https://docs.amd.com/r/en-US/ug835-vivado-tcl-commands/add_files
       |add_files -fileset $$source_fileset ${k.sourcesDir}
       |
       |# TODO add other filesets (constraints, etc.)
       |
       |source ${k.bdLoadFile}
       |
       |""".stripMargin
  }
}
